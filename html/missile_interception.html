<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>missile_interception</title>
<meta name="generator" content="MATLAB 24.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-07-16">
<meta name="DC.source" content="missile_interception.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#2">Clear workspace and close all figures</a>
</li>
<li>
<a href="#3">Step I &ndash; Simulation of the ballistic missile trajectory</a>
</li>
<li>
<a href="#4">Step II &ndash; Spectral analysis and modeling of the noise you have simulated</a>
</li>
<li>
<a href="#5">Step III &ndash; Trajectory prediction The missile</a>
</li>
<li>
<a href="#6">Step IV &ndash; Comparison and Evaluation</a>
</li>
<li>
<a href="#7">Step V &ndash; Simulation Animation</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="comment">% DRSP course project</span>
<span class="comment">% Ballistic Missile Interception Simulation and Prediction</span>
<span class="comment">% Author: Jordan Jacob</span>
<span class="comment">% ID: 316495522</span>
<span class="comment">% Date: 12/07/2025</span>
</pre>
<h2 id="2">Clear workspace and close all figures</h2>
<pre class="codeinput">clear;
close <span class="string">all</span>;
clc;
</pre>
<h2 id="3">Step I &ndash; Simulation of the ballistic missile trajectory</h2>
<pre class="codeinput">
<span class="comment">% A. Define parameters and simulate the clean trajectory</span>
xtarget = 2300;             <span class="comment">% Expected x-coordinate of impact (in km)</span>
yt = 0;                     <span class="comment">% y-coordinate remains 0 (2D trajectory)</span>
zt = 0;                     <span class="comment">% z = 0 at impact</span>

x0 = 0;                     <span class="comment">% Launch point x (Iran)</span>
y0 = 0;                     <span class="comment">% Launch point y</span>
z0 = 0;                     <span class="comment">% Launch point z</span>

xa = 2250;                  <span class="comment">% Arrow missile (interceptor) x position</span>
ya = 50;                    <span class="comment">% Arrow y position</span>
za = 0;                     <span class="comment">% Arrow z position</span>

h = 1200;                   <span class="comment">% Maximum height of missile (vertex of parabola)</span>
Ttotal = 600;               <span class="comment">% Total simulation time in seconds</span>
N = 2048;                   <span class="comment">% Number of time samples in the simulation</span>

b = xtarget / 2;            <span class="comment">% x-location of the peak height</span>
c = h;                      <span class="comment">% z-location of the peak height</span>
a = -h / b^2;               <span class="comment">% Coefficient that defines curvature of parabola</span>

T = linspace(0, Ttotal, N);            <span class="comment">% Time vector</span>
x = linspace(0, xtarget, N);           <span class="comment">% Horizontal position vector</span>

zb = a * (x - b).^2 + c;               <span class="comment">% Parabolic formula for the ballistic arc</span>

<span class="comment">% B. Simulate AR(1) noise and add it to clean trajectory</span>
sigmaW = 1;                                <span class="comment">% Noise standard deviation</span>
whiteNoise = sigmaW * randn(1, N);         <span class="comment">% Generate white noise</span>
noise = filter(1, [1, -0.8], whiteNoise);  <span class="comment">% Pass white noise through AR(1) filter</span>
zbNoisy = zb + noise;                      <span class="comment">% Add noise to clean trajectory to simulate measurement</span>

<span class="comment">% C. Plot the clean and noisy trajectories in 2D and 3D</span>
figure;
plot(x, zb, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">'x [km]'</span>);
ylabel(<span class="string">'z [km]'</span>);
title(<span class="string">'Clean Ballistic Trajectory'</span>);
grid <span class="string">on</span>;

figure;
plot3(x, zeros(size(x)), zb, <span class="string">'b'</span>, <span class="string">'LineWidth'</span>, 1);
hold <span class="string">on</span>;
plot3(x, zeros(size(x)), zbNoisy, <span class="string">'Color'</span>, [0.5 0.5 0.5],<span class="string">'LineWidth'</span>, 2);
plot3(xa, ya, za, <span class="string">'rp'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'r'</span>, <span class="string">'MarkerSize'</span>, 10);
xlabel(<span class="string">'x [km]'</span>);
ylabel(<span class="string">'y [km]'</span>);
zlabel(<span class="string">'z [km]'</span>);
title(<span class="string">'3D Missile Trajectory'</span>);
grid <span class="string">on</span>;
legend(<span class="string">'Clean'</span>,<span class="string">'Noisy'</span>,<span class="string">'Interceptor'</span>);
</pre>
<img vspace="5" hspace="5" src="missile_interception_01.png" alt=""> <img vspace="5" hspace="5" src="missile_interception_02.png" alt=""> <h2 id="4">Step II &ndash; Spectral analysis and modeling of the noise you have simulated</h2>
<pre class="codeinput">
<span class="comment">% A. Estimate the power spectral density of the noise using the periodogram</span>
periodogramPSD = zeros(1, N);
<span class="keyword">for</span> k = 1:N
    S = sum(noise .* exp(-1j*2*pi*(k-1)*(0:N-1)/N));
    periodogramPSD(k) = (1/N) * abs(S)^2;
<span class="keyword">end</span>
f = (0:N-1)/N;

<span class="comment">% Estimate PSD using the Welch method (Corrected Welch: 50% overlap + Hamming window)</span>
M = 256;
D = M/2;
w = hamming(M)';
U = sum(w.^2);
K = floor((N - M) / D) + 1;

PxWelch = zeros(1, M);
<span class="keyword">for</span> k = 0:K-1
    idx = k*D + (1:M);
    segment = noise(idx) .* w;
    Pseg = abs(fft(segment)).^2;
    PxWelch = PxWelch + Pseg;
<span class="keyword">end</span>
PxWelch = PxWelch / (K * U);
fWelch = (0:M-1)/M;

<span class="comment">% Estimate PSD using the Yule-Walker method with xcorr for autocorrelation</span>
p = 1;
[rxx, lags] = xcorr(noise, p, <span class="string">'unbiased'</span>);
rxx = rxx(lags &gt;= 0);
RYw = toeplitz(rxx(1:p));
rVec = rxx(2:p+1);

aYw = -RYw \ rVec;
aCoeff = [1; aYw];

<span class="comment">% Estimate innovation variance sigma^2 using the Yule-Walker equation</span>
sigmaYW = rxx(1) + aYw * rxx(2);

<span class="comment">% Evaluate PSD using direct formula, not freqz</span>
fYw = linspace(0, 0.5, 512);
omegaYw = 2 * pi * fYw;
PYw = sigmaYW ./ abs(1 + aYw * exp(-1j * omegaYw)).^2;

omega = 2 * pi * f;
Ptheory = sigmaW^2 ./ abs(1 - 0.8 * exp(-1j * omega)).^2;

<span class="comment">% B. Theoretical PSD, and the estimators PSD's on the same set of axes</span>
<span class="comment">% Align all vectors to common plotting length</span>
minLen = min([length(fYw), floor(N/2)+1, floor(M/2)+1]);
f1 = linspace(0, 0.5, minLen);
PxPer1 = periodogramPSD(1:minLen);
fWelch1 = fWelch(1:minLen);
PxWelch1 = PxWelch(1:minLen);
PYw1 = PYw(1:minLen);
Ptheory1 = Ptheory(1:minLen);

figure;
plot(f1, PxPer1, <span class="string">'b'</span>, fWelch1, PxWelch1, <span class="string">'r'</span>, f1, PYw1, <span class="string">'g'</span>, f1, Ptheory1, <span class="string">'k--'</span>);
xlabel(<span class="string">'Frequency [Hz]'</span>); ylabel(<span class="string">'PSD [Power/Hz]'</span>);
title(<span class="string">'Noise PSD Estimation'</span>); grid <span class="string">on</span>;
legend(<span class="string">'Periodogram'</span>,<span class="string">'Welch'</span>,<span class="string">'Yule-Walker'</span>,<span class="string">'Theoretical'</span>);
</pre>
<img vspace="5" hspace="5" src="missile_interception_03.png" alt=""> <h2 id="5">Step III &ndash; Trajectory prediction The missile</h2>
<pre class="codeinput">
<span class="comment">% a. Use a matched filter on the noisy signal to find the beginning of the descent phase</span>
segmentLength = round(N/4);
matchedTemplate = zb(end - segmentLength + 1:end) - mean(zb(end - segmentLength + 1:end)); <span class="comment">% subtract the mean to reduce DC bias - center the signal and to improve SNR</span>
matchedFilter = conv(zbNoisy - mean(zbNoisy), flip(matchedTemplate), <span class="string">'same'</span>); <span class="comment">% flip the template for time-reversal</span>
<span class="comment">% signal is real-valued, conjugation is redundant</span>
[~, descentIndex] = max(matchedFilter);
tDescent = T(descentIndex);

<span class="comment">% b. Polynomial fit of the trajectory after descent</span>
segmentSamples = round(15 * N / Ttotal);
fitIndices = descentIndex : min(descentIndex + segmentSamples - 1, N);
xFit = x(fitIndices)';
zFit = zbNoisy(fitIndices)';

polyCoeffs = polyfit(xFit, zFit, 2);

xPolyPred = x(fitIndices(end):end)';
zPolyPred = polyval(polyCoeffs, xPolyPred);

<span class="comment">% b. Wiener FIR prediction, alpha seconds ahead</span>
alpha = round(5 * N / Ttotal);
pw = 20;
L = pw + alpha;
rWiener = zeros(L+1,1);
<span class="keyword">for</span> k = 0:L
    rWiener(k+1) = sum(zbNoisy(descentIndex:end-k) .* zbNoisy(descentIndex+k:end)) / (N - descentIndex + 1);
<span class="keyword">end</span>
Rw = toeplitz(rWiener(1:pw));
rc = rWiener(alpha+1 : alpha+pw);
hWiener = Rw \ rc;

zWienerPred = nan(1, N);
<span class="keyword">for</span> n = descentIndex + pw : N - alpha
    <span class="comment">% Predicts alpha steps ahead using past pw samples of the noisy signal</span>
    <span class="comment">% The delay alpha affects how far into the future we attempt to predict, creating a lag in real-time application</span>
    zWienerPred(n + alpha) = hWiener' * zbNoisy(n-1:-1:n-pw)';
<span class="keyword">end</span>

<span class="comment">% c. Calculate intercept location and time at 150 km altitude</span>
interceptAlt = 150;
idxPolyIntercept = find(zPolyPred &lt;= interceptAlt, 1);
validWien = (descentIndex + alpha):N;
idxWienIntercept = validWien(find(zWienerPred(validWien) &lt;= interceptAlt, 1));

xInterceptPoly = xPolyPred(idxPolyIntercept);
zInterceptPoly = zPolyPred(idxPolyIntercept);
xInterceptWien = x(idxWienIntercept);
zInterceptWien = zWienerPred(idxWienIntercept);

<span class="comment">% d. Calculate required missile launch time</span>
arrowSpeed = 2.5; <span class="comment">% Arrow missile speed in km/s</span>
tInterceptPoly = T(fitIndices(end) + idxPolyIntercept - 1);
tInterceptWien = T(idxWienIntercept);

polyDistance = hypot(xInterceptPoly - xa, zInterceptPoly - za);
wienDistance = hypot(xInterceptWien - xa, zInterceptWien - za);

launchTimePoly = tInterceptPoly - polyDistance / arrowSpeed;
launchTimeWien = tInterceptWien - wienDistance / arrowSpeed;

<span class="comment">% Print results for c and d sections</span>
<span class="comment">% These values indicate when the descent starts, the estimated intercept points and times,</span>
<span class="comment">% and when the interceptor must be launched to successfully meet the missile.</span>
<span class="comment">% These are critical for evaluating system performance and responsiveness.</span>
disp(<span class="string">'Step III Results:'</span>);
fprintf(<span class="string">'Descent detected at t = %.2f s\n'</span>, tDescent);
fprintf(<span class="string">'Polynomial intercept: x=%.1f z=%.1f km, t=%.2f s, launch=%.2f s\n'</span>, xInterceptPoly, zInterceptPoly, tInterceptPoly, launchTimePoly);
fprintf(<span class="string">'Wiener intercept:    x=%.1f z=%.1f km, t=%.2f s, launch=%.2f s\n'</span>, xInterceptWien, zInterceptWien, tInterceptWien, launchTimeWien);

<span class="comment">% e. Add to 3D plot the arrow interception paths</span>
figure;
plot3(x, zeros(size(x)), zbNoisy, <span class="string">'Color'</span>, [0.5 0.5 0.5]); hold <span class="string">on</span>;
plot3([xa, xInterceptPoly], [ya, 0], [za, zInterceptPoly], <span class="string">'g--'</span>, <span class="string">'LineWidth'</span>, 2);
plot3([xa, xInterceptWien], [ya, 0], [za, zInterceptWien], <span class="string">'m--'</span>, <span class="string">'LineWidth'</span>, 2);
plot3(xa, ya, za, <span class="string">'rp'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'r'</span>);
plot3(xInterceptPoly, 0, zInterceptPoly, <span class="string">'go'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'g'</span>);
plot3(xInterceptWien, 0, zInterceptWien, <span class="string">'ms'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'m'</span>);
xlabel(<span class="string">'x [km]'</span>);
ylabel(<span class="string">'y [km]'</span>);
zlabel(<span class="string">'z [km]'</span>);
title(<span class="string">'Intercept Geometry'</span>);
grid <span class="string">on</span>;
legend(<span class="string">'Noisy'</span>,<span class="string">'Poly Arrow'</span>,<span class="string">'Wiener Arrow'</span>,<span class="string">'Interceptor'</span>,<span class="string">'Poly Intercept'</span>,<span class="string">'Wiener Intercept'</span>);
</pre>
<pre class="codeoutput">Step III Results:
Descent detected at t = 524.96 s
Polynomial intercept: x=2209.0 z=148.2 km, t=576.26 s, launch=514.74 s
Wiener intercept:    x=2237.1 z=147.5 km, t=583.59 s, launch=524.37 s
</pre>
<img vspace="5" hspace="5" src="missile_interception_04.png" alt=""> <h2 id="6">Step IV &ndash; Comparison and Evaluation</h2>
<p>Display numerical comparison between methods</p>
<pre class="codeinput">
<span class="comment">% Evaluate Accuracy over 1 Trials</span>

fprintf(<span class="string">'\nStep IV &ndash; Comparison:\n'</span>);
fprintf(<span class="string">'Polynomial method error at intercept (z): %.2f km\n'</span>, abs(zInterceptPoly - interceptAlt));
fprintf(<span class="string">'Wiener method error at intercept (z): %.2f km\n'</span>, abs(zInterceptWien - interceptAlt));

<span class="comment">% Evaluate Accuracy over 100 Trials</span>

nTrials = 100;
errorsPoly = nan(1, nTrials);
errorsWien = nan(1, nTrials);

<span class="keyword">for</span> trial = 1:nTrials
    <span class="comment">% Generate new noise + noisy trajectory</span>
    wn = sigmaW * randn(1, N);
    noiseTrial = filter(1, [1, -0.8], wn);
    zbTrial = zb + noiseTrial;

    <span class="comment">% Matched filter for descent detection</span>
    matchedTemplate = zb(end - segmentLength + 1:end) - mean(zb(end - segmentLength + 1:end));
    matchedFilter = conv(zbTrial - mean(zbTrial), flip(matchedTemplate), <span class="string">'same'</span>);
    [~, descentIdx] = max(matchedFilter);

    <span class="comment">% Polynomial method</span>
    fitIdx = descentIdx : min(descentIdx + segmentSamples - 1, N);
    xFit = x(fitIdx)';
    zFit = zbTrial(fitIdx)';
    coeffs = polyfit(xFit, zFit, 2);
    xPolyPred = x(fitIdx(end):end)';
    zPolyPred = polyval(coeffs, xPolyPred);
    idxPoly = find(zPolyPred &lt;= interceptAlt, 1);

    <span class="keyword">if</span> ~isempty(idxPoly)
        errPoly = abs(zPolyPred(idxPoly) - interceptAlt);
    <span class="keyword">else</span>
        errPoly = NaN; <span class="comment">% No intercept found</span>
    <span class="keyword">end</span>

    <span class="comment">% Wiener method</span>
    rWien = zeros(L+1,1);
    <span class="keyword">for</span> k = 0:L
        rWien(k+1) = sum(zbTrial(descentIdx:end-k) .* zbTrial(descentIdx+k:end)) / (N - descentIdx + 1);
    <span class="keyword">end</span>
    Rw = toeplitz(rWien(1:pw));
    rc = rWien(alpha+1 : alpha+pw);
    hWien = Rw \ rc;

    zWienPred = nan(1, N);
    <span class="keyword">for</span> n = descentIdx + pw : N - alpha
        zWienPred(n + alpha) = hWien' * zbTrial(n-1:-1:n-pw)';
    <span class="keyword">end</span>
    validWien = (descentIdx + alpha):N;
    idxWien = validWien(find(zWienPred(validWien) &lt;= interceptAlt, 1));

    <span class="keyword">if</span> ~isempty(idxWien)
        errWien = abs(zWienPred(idxWien) - interceptAlt);
    <span class="keyword">else</span>
        errWien = NaN;
    <span class="keyword">end</span>

    <span class="comment">% Store errors</span>
    errorsPoly(trial) = errPoly;
    errorsWien(trial) = errWien;
<span class="keyword">end</span>

<span class="comment">% Compute stats ignoring NaNs</span>
meanPoly = mean(errorsPoly, <span class="string">'omitnan'</span>);
meanWien = mean(errorsWien, <span class="string">'omitnan'</span>);
varPoly = var(errorsPoly, <span class="string">'omitnan'</span>);
varWien = var(errorsWien, <span class="string">'omitnan'</span>);

fprintf(<span class="string">'\nStep VI &ndash; Accuracy Evaluation:\n'</span>);
fprintf(<span class="string">'Polynomial: Mean Error = %.2f km, Variance = %.2f\n'</span>, meanPoly, varPoly);
fprintf(<span class="string">'Wiener:     Mean Error = %.2f km, Variance = %.2f\n'</span>, meanWien, varWien);

<span class="comment">% Plot</span>
figure;
boxplot([errorsPoly', errorsWien'], <span class="string">'Labels'</span>, {<span class="string">'Polynomial'</span>, <span class="string">'Wiener'</span>});
ylabel(<span class="string">'Error at Intercept Altitude [km]'</span>);
title(<span class="string">'Error Comparison over 100 Trials'</span>);
grid <span class="string">on</span>;


<span class="comment">% differences in accuracy, delay, reliability</span>
fprintf(<span class="string">'Discussion:\n'</span>);
fprintf(<span class="string">'- Polynomial fit is more stable but depends heavily on the chosen fitting segment.\n'</span>);
fprintf(<span class="string">'- Wiener prediction is better for forecasting but more sensitive to noise and estimation errors.\n'</span>);
fprintf(<span class="string">'- In real-time, Wiener filter may be more adaptable but riskier unless tuned well.\n'</span>);
</pre>
<pre class="codeoutput">
Step IV &ndash; Comparison:
Polynomial method error at intercept (z): 1.77 km
Wiener method error at intercept (z): 2.52 km

Step VI &ndash; Accuracy Evaluation:
Polynomial: Mean Error = 1.26 km, Variance = 0.49
Wiener:     Mean Error = 1.33 km, Variance = 0.70
Discussion:
- Polynomial fit is more stable but depends heavily on the chosen fitting segment.
- Wiener prediction is better for forecasting but more sensitive to noise and estimation errors.
- In real-time, Wiener filter may be more adaptable but riskier unless tuned well.
</pre>
<img vspace="5" hspace="5" src="missile_interception_05.png" alt=""> <h2 id="7">Step V &ndash; Simulation Animation</h2>
<pre class="codeinput">
<span class="comment">% Animate the missile and interceptor paths over time</span>
<span class="comment">% We animate every 20 time steps to balance visual clarity and computational efficiency</span>
<span class="comment">% This shows missile motion and interceptor attempt visually over the full flight duration</span>
figure;
<span class="keyword">for</span> i = 1:20:N
    clf;
    plot3(x(1:i), zeros(1,i), zbNoisy(1:i), <span class="string">'k'</span>);
    hold <span class="string">on</span>;
    <span class="keyword">if</span> i &gt;= descentIndex + pw + alpha &amp;&amp; ~isnan(zWienerPred(i))
        plot3(xa, ya, za, <span class="string">'rp'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'r'</span>);
        plot3([xa, x(i)], [ya, 0], [za, zWienerPred(i)], <span class="string">'m--'</span>);
    <span class="keyword">end</span>
    xlim([0 xtarget]);
    ylim([-100 100]);
    zlim([0 1300]);
    xlabel(<span class="string">'x [km]'</span>);
    ylabel(<span class="string">'y [km]'</span>);
    zlabel(<span class="string">'z [km]'</span>);
    title(sprintf(<span class="string">'Time = %.1f s'</span>, T(i)));
    grid <span class="string">on</span>;
    drawnow;
<span class="keyword">end</span>
</pre>
<img vspace="5" hspace="5" src="missile_interception_06.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
% DRSP course project
% Ballistic Missile Interception Simulation and Prediction
% Author: Jordan Jacob
% ID: 316495522
% Date: 12/07/2025

%% Clear workspace and close all figures
clear; 
close all; 
clc;

%% Step I – Simulation of the ballistic missile trajectory

% A. Define parameters and simulate the clean trajectory
xtarget = 2300;             % Expected x-coordinate of impact (in km)
yt = 0;                     % y-coordinate remains 0 (2D trajectory)
zt = 0;                     % z = 0 at impact

x0 = 0;                     % Launch point x (Iran)
y0 = 0;                     % Launch point y
z0 = 0;                     % Launch point z

xa = 2250;                  % Arrow missile (interceptor) x position
ya = 50;                    % Arrow y position
za = 0;                     % Arrow z position

h = 1200;                   % Maximum height of missile (vertex of parabola)
Ttotal = 600;               % Total simulation time in seconds
N = 2048;                   % Number of time samples in the simulation

b = xtarget / 2;            % x-location of the peak height
c = h;                      % z-location of the peak height
a = -h / b^2;               % Coefficient that defines curvature of parabola

T = linspace(0, Ttotal, N);            % Time vector
x = linspace(0, xtarget, N);           % Horizontal position vector

zb = a * (x - b).^2 + c;               % Parabolic formula for the ballistic arc

% B. Simulate AR(1) noise and add it to clean trajectory
sigmaW = 1;                                % Noise standard deviation
whiteNoise = sigmaW * randn(1, N);         % Generate white noise
noise = filter(1, [1, -0.8], whiteNoise);  % Pass white noise through AR(1) filter
zbNoisy = zb + noise;                      % Add noise to clean trajectory to simulate measurement

% C. Plot the clean and noisy trajectories in 2D and 3D
figure;
plot(x, zb, 'LineWidth', 2);
xlabel('x [km]'); 
ylabel('z [km]');
title('Clean Ballistic Trajectory');
grid on;

figure;
plot3(x, zeros(size(x)), zb, 'b', 'LineWidth', 1); 
hold on;
plot3(x, zeros(size(x)), zbNoisy, 'Color', [0.5 0.5 0.5],'LineWidth', 2);
plot3(xa, ya, za, 'rp', 'MarkerFaceColor', 'r', 'MarkerSize', 10);
xlabel('x [km]'); 
ylabel('y [km]'); 
zlabel('z [km]');
title('3D Missile Trajectory'); 
grid on;
legend('Clean','Noisy','Interceptor');

%% Step II – Spectral analysis and modeling of the noise you have simulated

% A. Estimate the power spectral density of the noise using the periodogram
periodogramPSD = zeros(1, N);
for k = 1:N
    S = sum(noise .* exp(-1j*2*pi*(k-1)*(0:N-1)/N));
    periodogramPSD(k) = (1/N) * abs(S)^2;
end
f = (0:N-1)/N;

% Estimate PSD using the Welch method (Corrected Welch: 50% overlap + Hamming window)
M = 256;
D = M/2;
w = hamming(M)';
U = sum(w.^2);
K = floor((N - M) / D) + 1;

PxWelch = zeros(1, M);
for k = 0:K-1
    idx = k*D + (1:M);
    segment = noise(idx) .* w;
    Pseg = abs(fft(segment)).^2;
    PxWelch = PxWelch + Pseg;
end
PxWelch = PxWelch / (K * U);
fWelch = (0:M-1)/M;

% Estimate PSD using the Yule-Walker method with xcorr for autocorrelation
p = 1;
[rxx, lags] = xcorr(noise, p, 'unbiased');
rxx = rxx(lags >= 0);
RYw = toeplitz(rxx(1:p));
rVec = rxx(2:p+1);

aYw = -RYw \ rVec;
aCoeff = [1; aYw];

% Estimate innovation variance sigma^2 using the Yule-Walker equation
sigmaYW = rxx(1) + aYw * rxx(2);

% Evaluate PSD using direct formula, not freqz
fYw = linspace(0, 0.5, 512);
omegaYw = 2 * pi * fYw;
PYw = sigmaYW ./ abs(1 + aYw * exp(-1j * omegaYw)).^2;

omega = 2 * pi * f;
Ptheory = sigmaW^2 ./ abs(1 - 0.8 * exp(-1j * omega)).^2;

% B. Theoretical PSD, and the estimators PSD's on the same set of axes 
% Align all vectors to common plotting length
minLen = min([length(fYw), floor(N/2)+1, floor(M/2)+1]);
f1 = linspace(0, 0.5, minLen);
PxPer1 = periodogramPSD(1:minLen);
fWelch1 = fWelch(1:minLen);
PxWelch1 = PxWelch(1:minLen);
PYw1 = PYw(1:minLen);
Ptheory1 = Ptheory(1:minLen);

figure;
plot(f1, PxPer1, 'b', fWelch1, PxWelch1, 'r', f1, PYw1, 'g', f1, Ptheory1, 'kREPLACE_WITH_DASH_DASH');
xlabel('Frequency [Hz]'); ylabel('PSD [Power/Hz]');
title('Noise PSD Estimation'); grid on;
legend('Periodogram','Welch','Yule-Walker','Theoretical');

%% Step III – Trajectory prediction The missile

% a. Use a matched filter on the noisy signal to find the beginning of the descent phase
segmentLength = round(N/4);
matchedTemplate = zb(end - segmentLength + 1:end) - mean(zb(end - segmentLength + 1:end)); % subtract the mean to reduce DC bias - center the signal and to improve SNR
matchedFilter = conv(zbNoisy - mean(zbNoisy), flip(matchedTemplate), 'same'); % flip the template for time-reversal
% signal is real-valued, conjugation is redundant
[~, descentIndex] = max(matchedFilter);
tDescent = T(descentIndex);

% b. Polynomial fit of the trajectory after descent
segmentSamples = round(15 * N / Ttotal);
fitIndices = descentIndex : min(descentIndex + segmentSamples - 1, N);
xFit = x(fitIndices)';
zFit = zbNoisy(fitIndices)';

polyCoeffs = polyfit(xFit, zFit, 2);

xPolyPred = x(fitIndices(end):end)';
zPolyPred = polyval(polyCoeffs, xPolyPred);

% b. Wiener FIR prediction, alpha seconds ahead
alpha = round(5 * N / Ttotal);
pw = 20;
L = pw + alpha;
rWiener = zeros(L+1,1);
for k = 0:L
    rWiener(k+1) = sum(zbNoisy(descentIndex:end-k) .* zbNoisy(descentIndex+k:end)) / (N - descentIndex + 1);
end
Rw = toeplitz(rWiener(1:pw));
rc = rWiener(alpha+1 : alpha+pw);
hWiener = Rw \ rc;

zWienerPred = nan(1, N);
for n = descentIndex + pw : N - alpha
    % Predicts alpha steps ahead using past pw samples of the noisy signal
    % The delay alpha affects how far into the future we attempt to predict, creating a lag in real-time application
    zWienerPred(n + alpha) = hWiener' * zbNoisy(n-1:-1:n-pw)';
end

% c. Calculate intercept location and time at 150 km altitude
interceptAlt = 150;
idxPolyIntercept = find(zPolyPred <= interceptAlt, 1);
validWien = (descentIndex + alpha):N;
idxWienIntercept = validWien(find(zWienerPred(validWien) <= interceptAlt, 1));

xInterceptPoly = xPolyPred(idxPolyIntercept);
zInterceptPoly = zPolyPred(idxPolyIntercept);
xInterceptWien = x(idxWienIntercept);
zInterceptWien = zWienerPred(idxWienIntercept);

% d. Calculate required missile launch time
arrowSpeed = 2.5; % Arrow missile speed in km/s
tInterceptPoly = T(fitIndices(end) + idxPolyIntercept - 1);
tInterceptWien = T(idxWienIntercept);

polyDistance = hypot(xInterceptPoly - xa, zInterceptPoly - za);
wienDistance = hypot(xInterceptWien - xa, zInterceptWien - za);

launchTimePoly = tInterceptPoly - polyDistance / arrowSpeed;
launchTimeWien = tInterceptWien - wienDistance / arrowSpeed;

% Print results for c and d sections
% These values indicate when the descent starts, the estimated intercept points and times, 
% and when the interceptor must be launched to successfully meet the missile.
% These are critical for evaluating system performance and responsiveness.
disp('Step III Results:');
fprintf('Descent detected at t = %.2f s\n', tDescent);
fprintf('Polynomial intercept: x=%.1f z=%.1f km, t=%.2f s, launch=%.2f s\n', xInterceptPoly, zInterceptPoly, tInterceptPoly, launchTimePoly);
fprintf('Wiener intercept:    x=%.1f z=%.1f km, t=%.2f s, launch=%.2f s\n', xInterceptWien, zInterceptWien, tInterceptWien, launchTimeWien);

% e. Add to 3D plot the arrow interception paths
figure;
plot3(x, zeros(size(x)), zbNoisy, 'Color', [0.5 0.5 0.5]); hold on;
plot3([xa, xInterceptPoly], [ya, 0], [za, zInterceptPoly], 'gREPLACE_WITH_DASH_DASH', 'LineWidth', 2);
plot3([xa, xInterceptWien], [ya, 0], [za, zInterceptWien], 'mREPLACE_WITH_DASH_DASH', 'LineWidth', 2);
plot3(xa, ya, za, 'rp', 'MarkerFaceColor', 'r');
plot3(xInterceptPoly, 0, zInterceptPoly, 'go', 'MarkerFaceColor', 'g');
plot3(xInterceptWien, 0, zInterceptWien, 'ms', 'MarkerFaceColor', 'm');
xlabel('x [km]'); 
ylabel('y [km]'); 
zlabel('z [km]');
title('Intercept Geometry'); 
grid on; 
legend('Noisy','Poly Arrow','Wiener Arrow','Interceptor','Poly Intercept','Wiener Intercept');

%% Step IV – Comparison and Evaluation
% Display numerical comparison between methods

% Evaluate Accuracy over 1 Trials

fprintf('\nStep IV – Comparison:\n');
fprintf('Polynomial method error at intercept (z): %.2f km\n', abs(zInterceptPoly - interceptAlt));
fprintf('Wiener method error at intercept (z): %.2f km\n', abs(zInterceptWien - interceptAlt));

% Evaluate Accuracy over 100 Trials

nTrials = 100;
errorsPoly = nan(1, nTrials);
errorsWien = nan(1, nTrials);

for trial = 1:nTrials
    % Generate new noise + noisy trajectory
    wn = sigmaW * randn(1, N);
    noiseTrial = filter(1, [1, -0.8], wn);
    zbTrial = zb + noiseTrial;

    % Matched filter for descent detection
    matchedTemplate = zb(end - segmentLength + 1:end) - mean(zb(end - segmentLength + 1:end));
    matchedFilter = conv(zbTrial - mean(zbTrial), flip(matchedTemplate), 'same');
    [~, descentIdx] = max(matchedFilter);

    % Polynomial method
    fitIdx = descentIdx : min(descentIdx + segmentSamples - 1, N);
    xFit = x(fitIdx)';
    zFit = zbTrial(fitIdx)';
    coeffs = polyfit(xFit, zFit, 2);
    xPolyPred = x(fitIdx(end):end)';
    zPolyPred = polyval(coeffs, xPolyPred);
    idxPoly = find(zPolyPred <= interceptAlt, 1);

    if ~isempty(idxPoly)
        errPoly = abs(zPolyPred(idxPoly) - interceptAlt);
    else
        errPoly = NaN; % No intercept found
    end

    % Wiener method
    rWien = zeros(L+1,1);
    for k = 0:L
        rWien(k+1) = sum(zbTrial(descentIdx:end-k) .* zbTrial(descentIdx+k:end)) / (N - descentIdx + 1);
    end
    Rw = toeplitz(rWien(1:pw));
    rc = rWien(alpha+1 : alpha+pw);
    hWien = Rw \ rc;

    zWienPred = nan(1, N);
    for n = descentIdx + pw : N - alpha
        zWienPred(n + alpha) = hWien' * zbTrial(n-1:-1:n-pw)';
    end
    validWien = (descentIdx + alpha):N;
    idxWien = validWien(find(zWienPred(validWien) <= interceptAlt, 1));

    if ~isempty(idxWien)
        errWien = abs(zWienPred(idxWien) - interceptAlt);
    else
        errWien = NaN;
    end

    % Store errors
    errorsPoly(trial) = errPoly;
    errorsWien(trial) = errWien;
end

% Compute stats ignoring NaNs
meanPoly = mean(errorsPoly, 'omitnan');
meanWien = mean(errorsWien, 'omitnan');
varPoly = var(errorsPoly, 'omitnan');
varWien = var(errorsWien, 'omitnan');

fprintf('\nStep VI – Accuracy Evaluation:\n');
fprintf('Polynomial: Mean Error = %.2f km, Variance = %.2f\n', meanPoly, varPoly);
fprintf('Wiener:     Mean Error = %.2f km, Variance = %.2f\n', meanWien, varWien);

% Plot
figure;
boxplot([errorsPoly', errorsWien'], 'Labels', {'Polynomial', 'Wiener'});
ylabel('Error at Intercept Altitude [km]');
title('Error Comparison over 100 Trials');
grid on;


% differences in accuracy, delay, reliability
fprintf('Discussion:\n');
fprintf('- Polynomial fit is more stable but depends heavily on the chosen fitting segment.\n');
fprintf('- Wiener prediction is better for forecasting but more sensitive to noise and estimation errors.\n');
fprintf('- In real-time, Wiener filter may be more adaptable but riskier unless tuned well.\n');

%% Step V – Simulation Animation

% Animate the missile and interceptor paths over time
% We animate every 20 time steps to balance visual clarity and computational efficiency
% This shows missile motion and interceptor attempt visually over the full flight duration
figure;
for i = 1:20:N
    clf;
    plot3(x(1:i), zeros(1,i), zbNoisy(1:i), 'k'); 
    hold on;
    if i >= descentIndex + pw + alpha && ~isnan(zWienerPred(i))
        plot3(xa, ya, za, 'rp', 'MarkerFaceColor', 'r');
        plot3([xa, x(i)], [ya, 0], [za, zWienerPred(i)], 'mREPLACE_WITH_DASH_DASH');
    end
    xlim([0 xtarget]); 
    ylim([-100 100]); 
    zlim([0 1300]);
    xlabel('x [km]'); 
    ylabel('y [km]'); 
    zlabel('z [km]');
    title(sprintf('Time = %.1f s', T(i)));
    grid on; 
    drawnow;
end


##### SOURCE END #####
-->
</body>
</html>
